There are two major types of languages. Interpreted languages like Python,
Octave, MATLAB, and Tcl, where you write a script and another program reads
each line one at a time and interprets it on the fly. And Compiled languages
like C, Fortran, and Java, where you hand your program over to a compiler and
the compiler reads the code, checks for errors across the whole program, turns
your program into machine code and stores the machine code in a file that you
can execute, called an executable. Both have advantages and disadvantages. For
the most part we have focused on writing programs and building guis that use
interpreted languages. Here, we'll shift focus over to the compiled languages.

Two popular examples of compiled languages are C and Fortran. You'll hear some
people balk at the use of languages like C and Fortran. Some people will say
they are dead languages. But due to their speed in performing arithmetic and
the long history they have with numerical analysis libraries, these two
languages are sticking around for now. Not to mention that many of the current
languages still depend on C and Fortran based libraries.

If you have a program writen in C, you can use the gcc compiler to compile it
into an executable. The general command is shown at the top of the slide. The
command include some flags that give the compiler hints as to how to compile
the code. The -g flag tells the compiler to include debugging information in
the executable. This is helpful if we have to figure out why our program is not
running properly. Next we tell the compiler the name of our source code file,
plinko.c. Next we use the -o flag to tell the compiler to output an executable
file named "plink". Lastly we tell the compiler to link against the math
library, using the -lm flag. If the compiling works, we will have a file named
"plinko" in our directory. We can run the program on the command line by giving
the path to the executable, ./plinko.

Similarly, we can compile fortran code using the gfortran compiler. It takes
very similar flags. You may recognize the -g flag, telling the compiler to
include debugging information, and the -o flag, telling the compiler what to
name our executable file it outputs. We can run the fortran program in the same
way on the command line by giving the path to the executable.

Typically, as a developer, you spend a lot of time compiling your code, and
fixing errors and compiling again. Remembering and typing all of the compiler
flags can be tedious. Instead you can use something called a Makefile to store
your common compiling instructions. Instructions in a Makefile have three
parts. The target is like a label for the instruction. It is followed by a
colon and a list of dependencies. On the next line, indented with a TAB, is the
command or commands to run for the instruction. In the example makefile shown
on the slide, there are two instructions. The first is a target named plinko.
This target is used to compile the plink executable. Our gcc command is listed
right under the target. To use the make file to compile the plinko executable,
we can type "make" or "make plink", explicitly calling the target we want to
compile. So now, instead of typing out the whole line to compile the code, we
can just type "make". And if we want to remove our executable, we can call the
clean target by typing "make clean". Some things to note about Makefiles. The
file must be named "Makefile" with a capitol M, and the commands must be
indented with a TAB, not spaces.

If you are running a C or fortran program and it doesn't seem to be working
properly, you may need to run it in a debugger 
